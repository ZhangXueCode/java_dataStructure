import java.util.Stack;

public class Sort {
    public static void insertSort(int[] array){
        for (int i = 1; i < array.length; i++) {
            int tmp = array[i];
            int j = i-1;
            for (; j >=0 ; j--) {
                if(array[j] > array[i]) {
                    array[j+1] = array[j];
                }else {
                    break;
                }
            }
            array[j+1] = tmp;
        }

    }
    public static void shellSort(int[] array){
        int gap = array.length;
        while (gap > 1) {
            gap /= 2;
            shell(array,gap);
        }

    }

    private static void shell(int[] array, int gap) {
        for (int i = gap; i < array.length; i++) {
            int tmp = array[i];
            int j= i-gap;
            for (; j >=0 ; j-=gap) {
                if(array[j] > array[i]) {
                    array[j+gap] = array[j];
                }else {
                    break;
                }
            }
            array[j+gap] = tmp;
        }
    }
    public static void selectSort(int[] array){
        for (int i = 0; i < array.length; i++) {
            int MinIndex = i;
            int j = i+1;
            for (; j < array.length ; j++) {
                if(array[j] < array[MinIndex]) {
                    MinIndex = j;
                }
            }
            swap(array,MinIndex,i);
        }
    }
    public static void swap(int[] array,int i,int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    public static void selectSort2(int[] array) {
        int left = 0;
        int right = array.length-1;
        while (left < right) {
            int MinIndex = left;
            int MaxIndex = right;
            for (int i = left+1; i < right ; i++) {
                if(array[i] < array[MinIndex]) {
                    MinIndex = i;
                }
                if(array[i] > array[MaxIndex]) {
                    MaxIndex = i;
                }
            }
            swap(array,left,MinIndex);
            if(left==MaxIndex) {
                MaxIndex = MinIndex;
            }
            swap(array,right,MaxIndex);
            left++;
            right--;
        }
    }

    public static void heapSort(int[] array){
        int end = array.length-1;
        while (end > 0) {
            swap(array,0,end);
            shiftDown(array,0);
            end--;
        }

    }

    private static void shiftDown(int[] array,int parent) {
        int child = parent*2+1;
        while (child < array.length) {
            if(child+1 < array.length&&array[child] < array[child+1]) {
                child++;
            }
            if(array[child] < array[parent]) {
                swap(array,child,parent);
                parent = child;
                child = parent*2+1;
            }else {
                break;
            }
        }
    }
    public static void bubbleSort(int[] array){
        for (int i = 0; i < array.length-1; i++) {
            boolean flg = false;
            for (int j = 0; j < array.length-1-i; j++) {
                if(array[j] > array[j+1]) {
                    swap(array,j+1,j);
                    flg = true;
                }
            }
            if(!flg) {
                break;
            }
        }

    }
    public static void quickSort(int[] array){
        quick(array,0,array.length-1);

    }

    private static void quick(int[] array, int start, int end) {
        if(start>=end) {
            return;
        }
        if(end-start+1<=7) {
            quickInsertSort(array,start,end);
            return;
        }
        int mid = find(array,start,end);
        swap(array,mid,start);//这里能保证第一个数是中间大的数为基准数 避免了单边树的可能性

        int pivot = partitionHoare(array,start,end);
        quick(array,start,pivot-1);
        quick(array,pivot+1,end);
    }
    public static void quickInsertSort(int[] array,int start,int end){
        for (int i = start+1; i <= end; i++) {
            int tmp = array[i];
            int j = i-1;
            for (; j >=start ; j--) {
                if(array[j] > array[i]) {
                    array[j+1] = array[j];
                }else {
                    break;
                }
            }
            array[j+1] = tmp;
        }
    }
    public static int find(int[] array,int left,int right) {
        int mid = (left+right) / 2;
        if(array[left] > array[right]) {
            if(array[mid] > array[left]) {
                return left;
            } else if (array[mid] >array[right]) {
                return mid;
            }else {
                return right;
            }
        }else {
            if(array[mid] > array[right]) {
                return right;
            } else if (array[mid] > array[left]) {
                return mid;
            }else {
                return left;
            }
        }

    }
    public static int partitionHoare(int[] array,int start,int end) {
        int key = array[start];
        int i = start;
        while (start < end) {
            while (start < end && array[end] >= key) {
                end--;
            }
            while (start < end && array[start] <= key) {
                start++;
            }
            swap(array,start,end);
        }
        swap(array,start,i);
        return start;
    }
    //填坑法
    public static int partition(int[] array,int start,int end) {
        int key = array[start];
        while (start < end) {
            while (start < end && array[end] >= key) {
                end--;
            }
            array[start] = array[end];
            while (start < end && array[start] <= key) {
                start++;
            }
            array[end] = array[start];
        }
        array[start] = key;
        return start;
    }
    //指针法
    public static int partition2(int[] array,int left,int right) {
        int pre = left;
        int cur = left+1;
        while (cur <= right) {
            if(array[cur] > array[left] && array[++pre] != array[cur]) {
                swap(array,cur,pre);
            }
            cur++;
        }
        swap(array,pre,left);
        return pre;
    }
    //非递归形式
    public static void quickNor(int[] array) {
        int left = 0;
        int right = array.length;
        Stack<Integer> stack = new Stack<>();
        int pivot = partitionHoare(array,left,right);
        if(pivot-1 > left) {
            stack.push(pivot-1);
            stack.push(left);
        }
        if(pivot+1 < right) {
            stack.push(pivot+1);
            stack.push(right);
        }
        while (!stack.empty()) {
            right = stack.pop();
            left = stack.pop();
            pivot = partitionHoare(array,left,right);
            if(pivot-1 > left) {
                stack.push(pivot-1);
                stack.push(left);
            }
            if(pivot+1 < right) {
                stack.push(pivot+1);
                stack.push(right);
            }
        }
    }
    //归并排序
    public static void mergeSort(int[] array) {
        mergeSortFunc(array,0,array.length-1);
    }

    private static void mergeSortFunc(int[] array, int left, int right) {
        if(left>=right) return;
        int mid = (left+right) / 2;
        mergeSortFunc(array,left,mid);
        mergeSortFunc(array,mid+1,right);
        merge(array,left,right,mid);
    }
    public static void merge(int[] array,int left,int right,int mid) {
        int s1 = left;
        int s2 = mid+1;
        int k = 0;
        int[] tmp = new int[right-left+1];
        while (s1<=mid && s2<=right) {
            if(array[s1] < array[s2]) {
                tmp[k++] = array[s1++];
            }else {
                tmp[k++] = array[s2++];
            }
        }
        while (s1<=mid) {
            tmp[k++] = array[s1++];
        }
        while (s2<=right) {
            tmp[k++] = array[s2++];
        }
        for (int i = 0; i < tmp.length; i++) {
            array[i+left] = tmp[i];
        }
    }
    //非递归
    public static void mergeSortNor(int[] array) {
        int gap = 1;
        while (gap < array.length) {
            for (int i = 0; i < array.length; i += 2*gap) {
                int left = i;
                int mid = left+gap-1;
                int right = mid+gap;
                if(mid > array.length) {
                    mid = array.length-1;
                }
                if(right > array.length) {
                    right = array.length-1;
                }
                merge(array,left,right,mid);
            }
            gap *= 2;
        }
    }
    //计数排序
    public static void count(int[] array) {
        int min = array[0];
        int max = array[0];
        for (int i = 0; i < array.length; i++) {
            if(array[i] > max) {
                max = array[i];
            }
            if(array[i] < min) {
                min =array[i];
            }
        }
        int[] tmp = new int[max-min+1];
        for (int i = 0; i < array.length; i++) {
            tmp[array[i]-min]++;
        }
        int index = 0;
        for (int i = 0; i < tmp.length; i++) {
            while (tmp[i] > 0) {
                array[index] = i+min;
                tmp[i]--;
                index++;
            }
        }
    }


}
